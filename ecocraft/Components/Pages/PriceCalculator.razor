@page "/"
@implements IDisposable
@using ecocraft.Models
@using ecocraft.Services
@inject ContextService ContextService
@inject UserDataService UserDataService

<PageTitle>Price Calculator</PageTitle>

<MudContainer>
	<MudGrid>
		<!-- Première Colonne -->
		<MudItem sm="4" Class="border-solid border-2 mud-border-primary pa-4">
			<MudAutocomplete T="Skill" 
			                 Value="_emptySkill" 
			                 SearchFunc="SearchSkills" 
			                 ValueChanged="AddUserSkill" 
			                 Placeholder="Choose skills" 
			                 Dense="true" 
			                 MaxItems="null"
			                 Variant="Variant.Outlined" 
			                 AnchorOrigin="Origin.BottomLeft" 
			                 TransformOrigin="Origin.TopLeft">
			</MudAutocomplete>

			<MudTable Items="UserDataService.UserSkills" Dense="true">
				<HeaderContent>
					<MudTh>Name</MudTh>
					<MudTh>Level</MudTh>
					<MudTh>Action</MudTh>
				</HeaderContent>
				<RowTemplate>
					<MudTd>
						@context.Skill.Name
					</MudTd>
					<MudTd>
						<MudNumericField HideSpinButtons="true" T="int" Value=@context.Level Variant="Variant.Text" Min="0" Max="7" Style="width: 24px;" Immediate="true" ValueChanged="(int newValue) => OnLevelChanged(context,newValue)" />
					</MudTd>
					<MudTd>
						<MudIconButton Icon="@Icons.Material.Filled.Clear" aria-label="delete" Size="Size.Small" OnClick="@(() => RemoveUserSkill(context))"></MudIconButton>
					</MudTd>
				</RowTemplate>
			</MudTable>

			<MudDivider DividerType="DividerType.FullWidth" Class="my-6" />

			<MudAutocomplete T="CraftingTable"
			                 Value="_emptyCraftingTable"
			                 SearchFunc="SearchCraftingTables"
			                 ValueChanged="AddUserCraftingTable"
			                 Placeholder="Choose a crafting table..." 
			                 Dense="true"
			                 MaxItems="null"
			                 Variant="Variant.Outlined"
			                 AnchorOrigin="Origin.BottomLeft"
			                 TransformOrigin="Origin.TopLeft">
			</MudAutocomplete>

			<MudTable Items="UserDataService.UserCraftingTables" Dense="true">
				<HeaderContent>
					<MudTh>Name</MudTh>
					<MudTh>Upgrade</MudTh>
					<MudTh>Action</MudTh>
				</HeaderContent>
				<RowTemplate>
					<MudTd>
						@context.CraftingTable.Name
					</MudTd>
					<MudTd>
						<MudSelect T="PluginModule" Placeholder="Choose a module" Value=@context.PluginModule Dense="true" Variant="Variant.Outlined" ValueChanged="(PluginModule newPluginModule) => OnSelectedPluginModuleChanged(context, newPluginModule)" AnchorOrigin="Origin.BottomLeft" TransformOrigin="Origin.TopLeft">
							@foreach (var pluginModule in context.CraftingTable.PluginModules)
						{
							<MudSelectItem T="PluginModule" Value="@pluginModule">@pluginModule.Name</MudSelectItem>
						}
						</MudSelect> 
					</MudTd>
					<MudTd>
						<MudIconButton Icon="@Icons.Material.Filled.Clear" aria-label="delete" Size="Size.Small" OnClick="@(() => RemoveUserCraftingTable(context))"></MudIconButton>
					</MudTd>
				</RowTemplate>
			</MudTable> 
 		</MudItem>

		<!-- Deuxième Colonne -->
		<MudItem sm="4" Class="border-solid border-2 mud-border-primary pa-4">
			@* <MudStack>
				<MudStack Row AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
					<MudText>Price per 1000 calories</MudText>
					<div>
						<MudNumericField OnBlur="UpdateUser" T="decimal" @bind-Value="user.CalorieCost" HideSpinButtons="true" Variant="Variant.Outlined" Style="width: 40px;" />
					</div>
				</MudStack>
				<MudStack Justify="Justify.SpaceBetween" Row="true" Spacing="3" AlignItems="AlignItems.Center">
					<MudText>Profit percentage</MudText>
					<div>
						<MudNumericField OnBlur="UpdateUser" T="decimal" @bind-Value="user.ProfitMargin" HideSpinButtons="true" Variant="Variant.Text" Style="width: 40px;" />
					</div>
				</MudStack>
			</MudStack> *@
		</MudItem>

		<!-- Troisième Colonne -->
		<MudItem xs="12" sm="4" Class="border-solid border-2 mud-border-primary pa-4">
			<MudAutocomplete T="Recipe"
			                 Value="_emptyRecipe"
			                 SearchFunc="SearchRecipes"
			                 ValueChanged="AddUserRecipe"
			                 Placeholder="Ajouter une recette" 
			                 Dense="true"
			                 MaxItems="null"
			                 Variant="Variant.Outlined" 
			                 AnchorOrigin="Origin.BottomLeft" 
			                 TransformOrigin="Origin.TopLeft">
			</MudAutocomplete>

			<MudTable Items="UserDataService.UserRecipes" Dense="true">
				<HeaderContent>
					<MudTh>Name</MudTh>
					<MudTh>Price</MudTh>
					<MudTh>Action</MudTh>
				</HeaderContent>
				<RowTemplate>
					<MudTd>
						@context.Recipe.Name
					</MudTd>
					<MudTd>
						<MudTextField Disabled="true" Value="0"></MudTextField>
					</MudTd>
					<MudTd>
						<MudIconButton Icon="@Icons.Material.Filled.Clear" aria-label="delete" Size="Size.Small" OnClick="@(() => RemoveUserRecipe(context))"></MudIconButton>
					</MudTd>
				</RowTemplate>
			</MudTable>
		</MudItem>

	</MudGrid>
</MudContainer>

@code {
	private Skill? _emptySkill = null;
	private Recipe? _emptyRecipe = null;
	private CraftingTable? _emptyCraftingTable = null;

	protected override async Task OnInitializedAsync()
	{
		ContextService.OnContextChanged += StateHasChanged;
	}

	public void Dispose()
	{
		ContextService.OnContextChanged -= StateHasChanged;
	}
	
	private Task<IEnumerable<Skill>> SearchSkills(string value)
	{
		IEnumerable<Skill> result;

		if (string.IsNullOrEmpty(value))
		{
			result = UserDataService.GetAvailableSkills();
		}
		else
		{
			result = UserDataService.GetAvailableSkills()
				.Where(s => s.Name.Contains(value, StringComparison.InvariantCultureIgnoreCase))
				.ToList();
		}
		
		return Task.FromResult(result);
	}
	
	private Task<IEnumerable<Recipe>> SearchRecipes(string value)
	{
		IEnumerable<Recipe> result;
		
		if (string.IsNullOrEmpty(value))
		{
			result = UserDataService.GetAvailableRecipes();
		}
		else
		{
			result = UserDataService.GetAvailableRecipes()
				.Where(r => r.Name.Contains(value, StringComparison.InvariantCultureIgnoreCase))
				.ToList();
		}

		return Task.FromResult(result);
	}
	
	private Task<IEnumerable<CraftingTable>> SearchCraftingTables(string value)
	{
		IEnumerable<CraftingTable> result;

		if (string.IsNullOrEmpty(value))
		{
			result = UserDataService.GetAvailableCraftingTables();
		}
		else
		{
			result = UserDataService.GetAvailableCraftingTables()
				.Where(s => s.Name.Contains(value, StringComparison.InvariantCultureIgnoreCase))
				.ToList();
		}

		return Task.FromResult(result);
	}

	private void AddUserSkill(Skill? skill)
	{
		if (skill is null)
		{
			return;
		}
		
		var userSkill = new UserSkill
		{
			Skill = skill,
			UserServer = ContextService.CurrentUserServer!,
			Level = 1,
		};
		
		UserDataService.AddUserSkill(userSkill);
		
		_emptySkill = null;
	}

	private void RemoveUserSkill(UserSkill skill)
	{
		UserDataService.RemoveUserSkill(skill);
	}

	private void AddUserCraftingTable(CraftingTable? craftingTable)
	{
		if (craftingTable is null)
		{
			return;
		}
		
		var userCraftingTable = new UserCraftingTable
		{
			CraftingTable = craftingTable,
			UserServer = ContextService.CurrentUserServer!,
		};
		
		UserDataService.AddUserCraftingTable(userCraftingTable);
		
		_emptyCraftingTable = null;
	}

	private void RemoveUserCraftingTable(UserCraftingTable craftingTable)
	{
		UserDataService.RemoveUserCraftingTable(craftingTable);
	}

	private void AddUserRecipe(Recipe? recipe)
	{
		if (recipe is null)
		{
			return;
		}
		
		var userRecipe = new UserRecipe
		{
			Recipe = recipe,
			UserServer = ContextService.CurrentUserServer!,
		};
		
		UserDataService.AddUserRecipe(userRecipe);
		
		_emptySkill = null;
	}

	private void RemoveUserRecipe(UserRecipe recipe)
	{
		UserDataService.RemoveUserRecipe(recipe);
	}

	/*private async Task OnSelectedSkillsChanged(IEnumerable<Skill> newSelectedSkills)
	{
		// Mettre à jour les compétences dans la base de données (conversion en List)
		UserDataService.UpdateUserSkills(ContextService.CurrentUserServer, newSelectedSkills.ToList());

		// Récupère la liste des tables de craft correspondant aux skills sélectionné
		var selectedTable = UserDataService.UserSkills
			.SelectMany(us => us.Skill.Recipes)
			.Select(y => y.CraftingTable)
			.Distinct();

		// Mettre à jour les compétences dans la base de données (conversion en List)
		UserDataService.UpdateUserCraftingTables(ContextService.CurrentUserServer, selectedTable.ToList());

		userRecipes = UserDataService.GetAvailableRecipes();
	}

	private async Task OnSelectedRecipesChanged(IEnumerable<Recipe> newSelectedRecipes)
	{
		selectedRecipes = newSelectedRecipes;
	}

	private async Task OnSelectedCraftingTablesChanged(IEnumerable<CraftingTable> newSelectedCraftingTables)
	{
		UserDataService.UpdateUserCraftingTables(ContextService.CurrentUserServer, newSelectedCraftingTables.ToList());
	}*/

	private void OnLevelChanged(UserSkill userSkill, int newLevel)
	{
		// Mettre à jour le niveau de la compétence dans la base de données
		userSkill.Level = newLevel;
		// Comment gère-t-on l'argument limitToSkillLevelRecipes ?
		// userRecipes = UserDataService.GetAvailableRecipes();
	}

	private void OnSelectedPluginModuleChanged(UserCraftingTable userCraftingTable, PluginModule newUpgrade)
	{
		userCraftingTable.PluginModule = newUpgrade;
		// Mettre à jour le niveau de la compétence dans la base de données
		//await UserCraftingTableDbService.UpdateAsync(userCraftingTable);
	}
}
