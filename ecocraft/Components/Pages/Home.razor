@page "/"
@using Microsoft.EntityFrameworkCore
@using System.Text.Json
@using ecocraft.Extensions
@using ecocraft.Models
@using ecocraft.Services
@using ecocraft.Services.ImportData
@inject EcoCraftDbContext DbContext
@inject UserSkillService UserSkillService
@inject UserService UserService
@inject SkillService SkillService
@inject CraftingTableService CraftingTableService
@inject UserCraftingTableService UserCraftingTableService
@inject RecipeService RecipeService
@inject ItemOrTagService ItemOrTagService
@inject ElementService ElementService
@inject PluginModuleService PluginModuleService
@inject ServerService ServerService
@inject IJSRuntime JsRuntime
@inject IDialogService DialogService

<PageTitle>Eco Calc</PageTitle>

<MudContainer>

	<MudGrid>
		<!-- Première Colonne -->
		<MudItem sm="4" Class="border-solid border-2 mud-border-primary pa-4">
			<MudStack Row AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
					<MudSelect T="Server" Text="Choisissez un serveur" Label="Choisissez un serveur" @bind-Value="server" Dense="true" Variant="Variant.Outlined" SelectedValuesChanged="OnSelectedServerChanged">
						@foreach (var server in servers)
					{
						<MudSelectItem T="Server" Value="@server">@server.Name</MudSelectItem>
					}
				</MudSelect>
				<MudIconButton Icon="@Icons.Material.Filled.Add" Color="Color.Primary" aria-label="Create Server" OnClick="OpenServerDialog" />
			</MudStack>
			<MudTextField @bind-Value="serverName" Label="Server Name"></MudTextField>
			<MudFileUpload T="IBrowserFile" Context="fileInput" FilesChanged="UploadFiles">
				<ButtonTemplate>
					<MudButton HtmlTag="label"
							   Variant="Variant.Filled"
							   Color="Color.Primary"
							   StartIcon="@Icons.Material.Filled.CloudUpload"
							   for="@fileInput">
						Upload Files
					</MudButton>
				</ButtonTemplate>
			</MudFileUpload>

			<MudSelect T="Skill" Text="Choisissez vos compétences" SelectedValues=selectedSkills Label="Choisissez vos compétences" MultiSelection="true" Dense="true" Variant="Variant.Outlined" SelectedValuesChanged="OnSelectedSkillsChanged">
				@foreach (var skill in skills)
				{
					<MudSelectItem T="Skill" Value="@skill">@skill.Name</MudSelectItem>
				}
			</MudSelect>

			<MudTable Items="userSkills" Dense="true">
				<HeaderContent>
					<MudTh>Name</MudTh>
					<MudTh>Niveau</MudTh>
					<MudTh></MudTh>
				</HeaderContent>
				<RowTemplate>
					<MudTd>@context.Skill.Name</MudTd>
						<MudTd>
							<MudNumericField HideSpinButtons="true" T="int" Value=@context.Level Variant="Variant.Text" Min="0" Max="7" Style="width: 24px;" Immediate="true" ValueChanged="(int newValue) => OnLevelChanged(context,newValue)" />
						</MudTd>
						<MudTd>
							<MudIconButton Icon="@Icons.Material.Filled.Clear" aria-label="delete" Size="Size.Small"></MudIconButton>
						</MudTd>
					</RowTemplate>
				</MudTable>

				<MudDivider DividerType="DividerType.FullWidth" Class="my-6" />

				<MudSelect T="CraftingTable" Text="Choisissez une table..." SelectedValues=selectedCraftingTables Label="Choisissez une table..." MultiSelection="true" Dense="true" Variant="Variant.Outlined" SelectedValuesChanged="OnSelectedCraftingTablesChanged">
					@foreach (var table in craftingTables)
				{
					<MudSelectItem T="CraftingTable" Value="@table">@table.Name</MudSelectItem>
				}
				</MudSelect>

			  <MudTable Items="userCraftingTables" Dense="true">
				<HeaderContent>
					<MudTh>Name</MudTh>
					<MudTh>Upgrade</MudTh>
					<MudTh></MudTh>
				</HeaderContent>
				<RowTemplate>
					<MudTd>@context.CraftingTable.Name</MudTd>
						 <MudTd>
							<MudSelect T="PluginModule" Text="Choisissez un upgrade" Value="context.PluginModule" Label="Choisissez un upgrade" Dense="true" Variant="Variant.Outlined" ValueChanged="(PluginModule newPluginModule) => OnSelectedPluginModuleChanged(context, newPluginModule)">
								@foreach (var pluginModule in context.CraftingTable.PluginModules)
							{
								<MudSelectItem T="PluginModule" Value="@pluginModule">@pluginModule.Name</MudSelectItem>
							}
						</MudSelect> 
					</MudTd>
					<MudTd>
						<MudIconButton Icon="@Icons.Material.Filled.Clear" aria-label="delete" Size="Size.Small"></MudIconButton>
					</MudTd>
				</RowTemplate>
			</MudTable> 
 		</MudItem>

		<!-- Deuxième Colonne -->
		<MudItem sm="4" Class="border-solid border-2 mud-border-primary pa-4">
			<MudStack Row AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
				<MudSelect T="User" Text="Choisissez un utilisateur" Label="Choisissez un utilisateur" @bind-Value="user" Dense="true" Variant="Variant.Outlined" SelectedValuesChanged="OnSelectedUserChanged">
					@foreach (var user in users)
					{
						<MudSelectItem T="User" Value="@user">@user.Pseudo</MudSelectItem>
					}
				</MudSelect>
				<MudIconButton Icon="@Icons.Material.Filled.Add" Color="Color.Primary" aria-label="Create User" OnClick="OpenUserDialog" />
			</MudStack>
			@* <MudStack>
				<MudStack Row AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
					<MudText>Price per 1000 calories</MudText>
					<div>
						<MudNumericField OnBlur="UpdateUser" T="decimal" @bind-Value="user.CalorieCost" HideSpinButtons="true" Variant="Variant.Outlined" Style="width: 40px;" />
					</div>
				</MudStack>
				<MudStack Justify="Justify.SpaceBetween" Row="true" Spacing="3" AlignItems="AlignItems.Center">
					<MudText>Profit percentage</MudText>
					<div>
						<MudNumericField OnBlur="UpdateUser" T="decimal" @bind-Value="user.ProfitMargin" HideSpinButtons="true" Variant="Variant.Text" Style="width: 40px;" />
					</div>
				</MudStack>
			</MudStack> *@

		</MudItem>

		<!-- Troisième Colonne -->
		<MudItem xs="12" sm="4" Class="border-solid border-2 mud-border-primary pa-4">
			<MudSelect T="Recipe" Text="Choisissez vos recettes" SelectedValues=selectedRecipes Label="Choisissez vos recettes" MultiSelection="true" Dense="true" Variant="Variant.Outlined" SelectedValuesChanged="OnSelectedRecipesChanged">
				@foreach (var recipe in recipes)
				{
					<MudSelectItem T="Recipe" Value="@recipe">@recipe.Name</MudSelectItem>
				}
			</MudSelect>

			<MudTable Items="userRecipes" Dense="true">
				<HeaderContent>
					<MudTh>Name</MudTh>
					<MudTh>Price</MudTh>
					<MudTh>Hide</MudTh>
				</HeaderContent>
				<RowTemplate>
					<MudTd>@context.Name</MudTd>
					<MudTd>
					</MudTd>
					<MudTd>
						<MudIconButton Icon="@Icons.Material.Filled.Clear" aria-label="delete" Size="Size.Small"></MudIconButton>
					</MudTd>
			</RowTemplate>
		</MudTable>
		</MudItem>

	</MudGrid>




	</MudContainer>

	@code {

	private List<Skill> skills;
	private List<CraftingTable> craftingTables;
	private List<Recipe> recipes;
	private List<Element> elements;
	private List<ItemOrTag> itemOrTags;
	private List<User> users;
	private List<PluginModule> pluginModules;
	private List<Server> servers;

	private User user = new User();

	private IEnumerable<Skill> selectedSkills { get; set; } = new HashSet<Skill>();
	private IEnumerable<Recipe> selectedRecipes { get; set; } = new HashSet<Recipe>();
	private IEnumerable<UserSkill> userSkills { get; set; } = new HashSet<UserSkill>();

	private IEnumerable<CraftingTable> selectedCraftingTables { get; set; } = new HashSet<CraftingTable>();
	private IEnumerable<UserCraftingTable> userCraftingTables { get; set; } = new HashSet<UserCraftingTable>();

	private IEnumerable<Recipe> userRecipes { get; set; } = new HashSet<Recipe>();

	private int SkillsValue { get; set; }

	private string serverName = "";
	private Server? server;

	protected override async Task OnInitializedAsync()
	{
		// TODO: move to a better location
		await DbContext.Database.EnsureCreatedAsync();

		// TODO: retieve only from current server
		servers = await ServerService.GetAllAsync();

		skills = await SkillService.GetAllAsync();

		craftingTables = await CraftingTableService.GetAllAsync();

		users = await UserService.GetAllAsync();

		recipes = await RecipeService.GetAllAsync();

		elements = await ElementService.GetAllAsync();

		itemOrTags = await ItemOrTagService.GetAllAsync();

		pluginModules = await PluginModuleService.GetAllAsync();
	}

	IList<IBrowserFile> _files = new List<IBrowserFile>();

	private async Task UploadFiles(IBrowserFile? file)
	{
		if (serverName == "")
		{
			await JsRuntime.InvokeVoidAsync("alert", "Le server name ne peut pas être vide !"); // Alert
			return;
		}

		var foundServer = await ServerService.GetByNameAsync(serverName);

		if (foundServer is null)
		{
			server = new Server
			{
				Name = serverName,
			};

			await ServerService.AddAsync(server);
		}
		else
		{
			server = foundServer;
		}

		//var file = e.File;
		// On vérifie le type MIME pour s'assurer qu'il s'agit bien d'un fichier JSON
		if (file != null && file.ContentType == "application/json")
		{
			// On lit le fichier JSON en mémoire
			using var stream = file.OpenReadStream(2000000);
			using var memoryStream = new MemoryStream();
			await stream.CopyToAsync(memoryStream);

			memoryStream.Position = 0; // Repositionner au début pour la lecture
			using var reader = new StreamReader(memoryStream);
			string jsonContent = await reader.ReadToEndAsync();

			try
			{
				// Désérialiser le contenu JSON dans un objet C#
				ImportDataDto ImportedData = JsonSerializer.Deserialize<ImportDataDto>(jsonContent);

				ImportSkills(ImportedData.skills);

				ImportPluginModules(ImportedData.pluginModules);

				ImportCraftingTables(ImportedData.craftingTables);

				ImportRecipes(ImportedData.recipes, ImportedData.itemTagAssoc);

				ImportItemTagAssoc(ImportedData.itemTagAssoc);
			}
			catch (JsonException ex)
			{
				Console.WriteLine($"Erreur lors de la désérialisation JSON: {ex.Message}");
			}
		}
	}

	public async void ImportSkills(List<SkillDto> SkillDtos)
	{
		var namesToCheck = SkillDtos.Select(dto => dto.Name).ToList();

		// Récupère les noms qui existent déjà dans la base
		var existingNames = skills
			.Where(ct => namesToCheck.Contains(ct.Name))
			.Select(ct => ct.Name);

		// Ajouter uniquement les objets qui n'existent pas
		foreach (var dto in SkillDtos)
		{
			if (!existingNames.Contains(dto.Name))
			{
				var newSkill = new Skill
					{
						Name = dto.Name,
						Server = server,
					};

				skills.Add(newSkill);
				await SkillService.AddAsync(newSkill);
			}
		}
	}


	public async void ImportPluginModules(List<PluginModuleDto> PluginModuleDtos)
	{
		var namesToCheck = PluginModuleDtos.Select(dto => dto.Name).ToList();

		// Récupère les noms qui existent déjà dans la base
		var existingNames = pluginModules
			.Where(ct => namesToCheck.Contains(ct.Name))
			.Select(ct => ct.Name);

		// Ajouter uniquement les objets qui n'existent pas
		foreach (var dto in PluginModuleDtos)
		{
			if (!existingNames.Contains(dto.Name))
			{
				var newPluginModule = new PluginModule
					{
						Name = dto.Name,
						Percent = dto.Percent,
						Server = server,
					};

				pluginModules.Add(newPluginModule);
				await PluginModuleService.AddAsync(newPluginModule);
			}
		}

		var existinguserSkill = pluginModules.FirstOrDefault(pm => pm.Name.Contains("NoUpgrade") && pm.Server.Id == server.Id);
		if (existinguserSkill == null)
			await PluginModuleService.AddAsync(new PluginModule{Name = "NoUpgrade", Percent = 0, Server = server});

	}


	public async void ImportCraftingTables(List<CraftingTableDto> craftingTableDtos)
	{
		var namesToCheck = craftingTableDtos.Select(dto => dto.Name).ToList();

		// Récupère les noms qui existent déjà dans la base
		var existingNames = craftingTables
			.Where(ct => namesToCheck.Contains(ct.Name))
			.Select(ct => ct.Name);

		// Ajouter uniquement les objets qui n'existent pas
		foreach (var dto in craftingTableDtos)
		{
			if (!existingNames.Contains(dto.Name))
			{
				var newCraftingTable = new CraftingTable
					{
						Name = dto.Name,
						Server = server,
						PluginModules = dto.CraftingTablePluginModules.Select(ctpm => pluginModules.FirstOrDefault(pm => pm.Name == ctpm)).ToList()
					};

				craftingTables.Add(newCraftingTable);
				await CraftingTableService.AddAsync(newCraftingTable);
			}
		}
	}

	public async void ImportRecipes(List<RecipeDto> recipeDtos, List<ItemTagAssocDto> itemTagAssoc)
	{
		var namesToCheck = recipeDtos.Select(dto => dto.Name).ToList();

		// Récupère les noms qui existent déjà dans la base
		var existingRecipeNames = recipes
			.Where(ct => namesToCheck.Contains(ct.Name))
			.Select(ct => ct.Name);

		// Récupère les itemsOrTag qui existent déjà dans la base
		var existingItemOrTags = itemOrTags
			.Select(ct => ct.Name);

		// Ajouter uniquement les objets qui n'existent pas
		foreach (var recipeDto in recipeDtos)
		{
			if (!existingRecipeNames.Contains(recipeDto.Name))
			{
				var newRecipe = new Recipe
					{
						Name = recipeDto.Name,
						FamilyName = recipeDto.FamilyName,
						CraftMinutes = recipeDto.CraftMinutes,
						Skill = skills.FirstOrDefault(s => s.Name == recipeDto.RequiredSkill),
						SkillLevel = recipeDto.RequiredSkillLevel,
						IsBlueprint = recipeDto.IsBlueprint,
						IsDefault = recipeDto.IsDefault,
						Labor = recipeDto.Labor,
						CraftingTable = craftingTables.FirstOrDefault(c => c.Name == recipeDto.CraftingTable),
						Server = server,
					};

				recipes.Add(newRecipe);
				await RecipeService.AddAsync(newRecipe);

				// Si l'item or tag n'existe pas actuellement, on le crée, avant de créer l'element
				foreach (var recipeItem in recipeDto.Ingredients.Concat(recipeDto.Products))
				{
					if (!existingItemOrTags.Contains(recipeItem.ItemOrTag))
					{
						var itemOrTag = new ItemOrTag
						{
							Name = recipeItem.ItemOrTag,
							IsTag = itemTagAssoc.Select(t => t.Tag).Contains(recipeItem.ItemOrTag),
							Server = server,
						};

						itemOrTags.Add(itemOrTag);
						await ItemOrTagService.AddAsync(itemOrTag);
					}
				}

				foreach (var recipeDtoIngredient in recipeDto.Ingredients)
				{
					recipeDtoIngredient.Quantity *= -1;
				}

				foreach (var element in recipeDto.Ingredients.Concat(recipeDto.Products))
				{
					var itemOrTag = await ItemOrTagService.GetByNameAsync(element.ItemOrTag);
					var skill = skills.FirstOrDefault(s => s.Name == element.Skill);

					var ing = new Element
					{
						Recipe = newRecipe,
						ItemOrTag = itemOrTag,
						Quantity = element.Quantity,
						IsDynamic = element.IsDynamic,
						Skill = skill,
						LavishTalent = element.LavishTalent,
					};

					await ElementService.AddAsync(ing);
				}
			}
		}
	}

	public async void ImportItemTagAssoc(List<ItemTagAssocDto> itemTagAssoc)
	{
		foreach (var itemTag in itemTagAssoc)
		{
			var tag = itemOrTags.FirstOrDefault(i => i.Name == itemTag.Tag);

			if (tag is not null)
			{
				foreach (var type in itemTag.Types)
				{
					var item = itemOrTags.FirstOrDefault(i => i.Name == type);

					if (item is not null)
					{
						tag.AssociatedItemOrTags.Add(item);
					}
				}

				await ItemOrTagService.UpdateAsync(tag);
			}
		}
	}

	private async Task UpdateUser()
	{
		await UserService.UpdateAsync(user);
	}

	private async Task OnSelectedSkillsChanged(IEnumerable<Skill> newSelectedSkills)
	{
		// Mettre à jour la sélection localement
		selectedSkills = newSelectedSkills;

		// Mettre à jour les compétences dans la base de données (conversion en List)
		await UserSkillService.UpdateUserSkillsAsync(user, server, selectedSkills.ToList());

		userSkills = await UserSkillService.GetUserSkillsByUserAsync(user);

		// Récupère la liste des tables de craft correspondant aux skills sélectionné
		var selectedTable = userSkills
			.SelectMany(us => us.Skill.Recipes)
			.Select(y => y.CraftingTable)
			.Distinct();

		selectedCraftingTables = selectedTable.ToList();

		// Mettre à jour les compétences dans la base de données (conversion en List)
		await UserCraftingTableService.UpdateUserCraftingTablesAsync(user, server, selectedCraftingTables.ToList());

		userCraftingTables = await UserCraftingTableService.GetUserCraftingTablesByUserAsync(user);

		userRecipes = user.GetAvailableRecipes();

	}

	private async Task OnSelectedRecipesChanged(IEnumerable<Recipe> newSelectedRecipes)
	{
		selectedRecipes = newSelectedRecipes;
	}

	private async Task OnSelectedCraftingTablesChanged(IEnumerable<CraftingTable> newSelectedCraftingTables)
	{
		// Mettre à jour la sélection localement
		selectedCraftingTables = newSelectedCraftingTables;

		// Mettre à jour les compétences dans la base de données (conversion en List)
		await UserCraftingTableService.UpdateUserCraftingTablesAsync(user, server, selectedCraftingTables.ToList());

		userCraftingTables = await UserCraftingTableService.GetUserCraftingTablesByUserAsync(user);
	}


	private async Task OnLevelChanged(UserSkill userSkill, int newLevel)
	{
		// Mettre à jour le niveau de la compétence dans la base de données
		userSkill.Level = newLevel;
		await UserSkillService.UpdateAsync(userSkill);

		userRecipes = user.GetAvailableRecipes();
	}


	private async Task OnSelectedPluginModuleChanged(UserCraftingTable userCraftingTable, PluginModule newUpgrade)
	{
		userCraftingTable.PluginModule = newUpgrade;
		// Mettre à jour le niveau de la compétence dans la base de données
		await UserCraftingTableService.UpdateAsync(userCraftingTable);
	}

	private async Task OnSelectedUserChanged()
	{
		// Mettre à jour l'utilisateur
		if (user is not null)
		{
			// Charger les compétences de l'utilisateur à partir de l'objet user
			userSkills = await UserSkillService.GetUserSkillsByUserAsync(user);

			// Initialiser selectedSkills en tant que HashSet
			selectedSkills = new HashSet<Skill>(userSkills.Select(x => x.Skill));

			userCraftingTables = await UserCraftingTableService.GetUserCraftingTablesByUserAsync(user);
			selectedCraftingTables = new HashSet<CraftingTable>(userCraftingTables.Select(x => x.CraftingTable));

			userRecipes = user.GetAvailableRecipes();
		}
	}

	private async Task OnSelectedServerChanged()
	{
		if (server is not null && user is not null)
		{
			// Charger les compétences de l'utilisateur à partir de l'objet user
			userSkills = await UserSkillService.GetUserSkillsByUserAsync(user);

			// Initialiser selectedSkills en tant que HashSet
			selectedSkills = new HashSet<Skill>(userSkills.Select(x => x.Skill));

			userCraftingTables = await UserCraftingTableService.GetUserCraftingTablesByUserAsync(user);
			selectedCraftingTables = new HashSet<CraftingTable>(userCraftingTables.Select(x => x.CraftingTable));

			userRecipes = user.GetAvailableRecipes();
		}
	}

	private async Task OpenUserDialog()
	{
		var parameters = new DialogParameters();
		var dialog = DialogService.Show<UserDialog>("Créer un utilisateur", parameters);

		var result = await dialog.Result;

		if (!result.Cancelled)
		{
			User newUser = new User { Pseudo = result.Data.ToString() };
			newUser.UserSettings.Add(new UserSetting { User = newUser, Server = server});
			await UserService.AddAsync(newUser);
			user = newUser;
			//userName = result.Data.ToString(); // Récupère le nom de l'utilisateur saisi
			users = await UserService.GetAllAsync();
			OnSelectedUserChanged();
		}
	}

	private async Task OpenServerDialog()
	{
		var parameters = new DialogParameters();
		var dialog = DialogService.Show<ServerDialog>("Créer un serveur", parameters);

		var result = await dialog.Result;

		if (!result.Cancelled)
		{
			Server newServer = new Server { Name = result.Data.ToString() };
			await ServerService.AddAsync(newServer);
			server = newServer;
			servers = await ServerService.GetAllAsync();
			OnSelectedUserChanged();
		}
	}
	
	/*private async Task DeleteUserSkill(int userSkillId)
		{
		// Appel au service pour supprimer la compétence de l'utilisateur
		await UserSkillService.DeleteUserSkillAsync(userSkillId);

		// Charger les compétences de l'utilisateur à partir de l'objet user
		userSkills = await UserSkillService.GetUserSkillsByUserAsync(user);

		// Initialiser selectedSkills en tant que HashSet
		selectedSkills = new HashSet<Skill>(userSkills.Select(x => x.Skill));
				}*/
}
